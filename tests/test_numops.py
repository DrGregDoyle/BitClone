"""
Testing the numeric op_codes
Generated by ChatGPT
"""
# tests/test_numeric_ops.py
import pytest

from src.core import BitStackError
from src.script.opcodes.numeric import (
    op_1add, op_1sub, op_negate, op_abs, op_not, op_0notequal,
    op_add, op_sub, op_booland, op_boolor,
    op_numequal, op_numequalverify, op_numnotequal,
    op_lessthan, op_greaterthan, op_lessthanorequal, op_greaterthanorequal,
    op_min, op_max, op_within,
)
from src.script.stack import BitStack, BitNum


# -----------------
# Helpers
# -----------------

def stack_top_nums(*ints: int) -> BitStack:
    """
    Create a stack where the FIRST integer is the TOP (leftmost).
    We push in reverse so the first ends up on top regardless of push semantics.
    """
    s = BitStack()
    for n in reversed(ints):
        s.push(BitNum(n))
    return s


def peek_top_int(s: BitStack) -> int:
    """Non-destructively read top as int."""
    v = s.popnum()
    s.push(BitNum(v))
    return v


# -----------------
# Unary ops
# -----------------

@pytest.mark.parametrize("x,expected", [(0, 1), (1, 2), (-1, 0), (127, 128), (-128, -127)])
def test_op_1add(x, expected):
    s = stack_top_nums(x)
    op_1add(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("x,expected", [(0, -1), (1, 0), (-1, -2), (128, 127), (-128, -129)])
def test_op_1sub(x, expected):
    s = stack_top_nums(x)
    op_1sub(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("x,expected", [(0, 0), (5, -5), (-5, 5)])
def test_op_negate(x, expected):
    s = stack_top_nums(x)
    op_negate(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("x,expected", [(-5, 5), (5, 5), (0, 0)])
def test_op_abs(x, expected):
    s = stack_top_nums(x)
    op_abs(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("x,expected", [(0, 1), (5, 0), (-7, 0)])
def test_op_not(x, expected):
    s = stack_top_nums(x)
    op_not(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("x,expected", [(0, 0), (5, 1), (-7, 1)])
def test_op_0notequal(x, expected):
    s = stack_top_nums(x)
    op_0notequal(s)
    assert s.popnum() == expected


# -----------------
# Binary arithmetic / boolean
# -----------------

@pytest.mark.parametrize("a,b,expected", [(2, 3, 5), (-2, 3, 1), (100, -1, 99)])
def test_op_add(a, b, expected):
    # top is a, next is b (order matters for how you push)
    s = stack_top_nums(a, b)
    op_add(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("a,b,expected", [(2, 3, 1), (3, 2, -1), (-2, 3, 5)])
def test_op_sub(a, b, expected):
    # spec: push (a,b) with a on top; op_sub computes b - a
    s = stack_top_nums(a, b)
    op_sub(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("a,b,expected", [
    (0, 0, 0), (0, 2, 0), (3, 0, 0), (3, 4, 1), (-5, 6, 1)
])
def test_op_booland(a, b, expected):
    s = stack_top_nums(a, b)
    op_booland(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("a,b,expected", [
    (0, 0, 0), (0, 2, 1), (3, 0, 1), (3, 4, 1), (-5, 0, 1)
])
def test_op_boolor(a, b, expected):
    s = stack_top_nums(a, b)
    op_boolor(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("a,b,expected", [(2, 2, 1), (2, 3, 0), (-1, -1, 1), (0, 1, 0)])
def test_op_numequal(a, b, expected):
    s = stack_top_nums(a, b)
    op_numequal(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("a,b,expected", [(2, 2, 0), (2, 3, 1), (-1, -1, 0), (0, 1, 1)])
def test_op_numnotequal(a, b, expected):
    s = stack_top_nums(a, b)
    op_numnotequal(s)
    assert s.popnum() == expected


def test_op_numequalverify_behaves_like_numequal_for_now():
    # Implementation currently only pushes the equality result (no VERIFY).
    s1 = stack_top_nums(5, 5)
    s2 = stack_top_nums(5, 5)
    op_numequal(s1)
    op_numequalverify(s2)
    assert s1.popnum() == 1 and s2.is_empty


# -----------------
# Comparisons (note: function pops a=top, b=next)
# -----------------

def test_op_lessthan():
    s = stack_top_nums(5, 2)  # a=5 (top), b=2 -> b<a => True
    op_lessthan(s)
    assert s.popnum() == 1

    s = stack_top_nums(2, 5)  # a=2, b=5 -> b<a => False
    op_lessthan(s)
    assert s.popnum() == 0


def test_op_greaterthan():
    s = stack_top_nums(5, 2)  # expect b>a? False
    op_greaterthan(s)
    assert s.popnum() == 0

    s = stack_top_nums(2, 5)  # b>a? True
    op_greaterthan(s)
    assert s.popnum() == 1


def test_op_lessthanorequal():
    s = stack_top_nums(5, 5)  # b<=a True
    op_lessthanorequal(s)
    assert s.popnum() == 1

    s = stack_top_nums(4, 5)  # b<=a False
    op_lessthanorequal(s)
    assert s.popnum() == 0


def test_op_greaterthanorequal():
    s = stack_top_nums(5, 5)  # b>=a True
    op_greaterthanorequal(s)
    assert s.popnum() == 1

    s = stack_top_nums(6, 5)  # b>=a False
    op_greaterthanorequal(s)
    assert s.popnum() == 0


# -----------------
# Min / Max
# -----------------

@pytest.mark.parametrize("a,b,expected", [(2, 3, 2), (3, 2, 2), (-1, 1, -1)])
def test_op_min(a, b, expected):
    s = stack_top_nums(a, b)
    op_min(s)
    assert s.popnum() == expected


@pytest.mark.parametrize("a,b,expected", [(2, 3, 3), (3, 2, 3), (-1, 1, 1)])
def test_op_max(a, b, expected):
    s = stack_top_nums(a, b)
    op_max(s)
    assert s.popnum() == expected


# -----------------
# OP_WITHIN (left-inclusive, right-exclusive)
# Pops: max, min, num (with num below min below max on the stack)
# -----------------

def test_op_within_basic_and_edges():
    # Within: _min <= num < _max
    # prepare stack with top=max, next=min, next=num
    s = stack_top_nums(10, 3, 5)  # 3 <= 5 < 10 -> True
    op_within(s)
    assert s.popnum() == 1

    s = stack_top_nums(10, 3, 3)  # 3 <= 3 < 10 -> True (left-inclusive)
    op_within(s)
    assert s.popnum() == 1

    s = stack_top_nums(10, 3, 10)  # 3 <= 10 < 10 -> False (right-exclusive)
    op_within(s)
    assert s.popnum() == 0

    s = stack_top_nums(10, 3, 2)  # 3 <= 2 < 10 -> False (below min)
    op_within(s)
    assert s.popnum() == 0


# -----------------
# Error cases (underflow)
# -----------------

def test_underflow_unary():
    s = BitStack()
    with pytest.raises(BitStackError):
        op_1add(s)
    with pytest.raises(BitStackError):
        op_not(s)


def test_underflow_binary():
    s = stack_top_nums(1)  # only one data
    with pytest.raises(BitStackError):
        op_add(s)
    with pytest.raises(BitStackError):
        op_lessthan(s)


def test_underflow_within():
    # Needs 3 items
    s = stack_top_nums(9, 1)  # only two
    with pytest.raises(BitStackError):
        op_within(s)
