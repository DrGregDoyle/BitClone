"""
Tests for the BitNum class — focus on MSB/sign-bit minimal encoding rules.
Each assert includes a message to make failures obvious.
Generated by ChatGPT
"""
from src.script import BitNum


def test_bitnum_zero_and_one():
    # Zero (empty bytes)
    zero = BitNum(0)
    assert zero == 0, "0: integer equivalence failed"
    assert zero == b"", "0: Script encoding should be empty bytes"
    assert zero == BitNum.from_bytes(b""), "0: round-trip from_bytes failed"

    # +1 / -1
    pos1 = BitNum(1)
    neg1 = BitNum(-1)
    assert pos1 == 1 and pos1.to_bytes() == b"\x01", "+1: wrong minimal encoding"
    assert neg1 == -1 and neg1.to_bytes() == b"\x81", "-1: wrong minimal encoding"
    assert BitNum.from_bytes(b"\x01") == pos1, "+1: from_bytes failed"
    assert BitNum.from_bytes(b"\x81") == neg1, "-1: from_bytes failed"


def test_bitnum_msb_edges_single_byte():
    # 127 / -127 (0x7f has MSB bit clear; can encode in a single byte)
    p127 = BitNum(127)
    n127 = BitNum(-127)
    assert p127.to_bytes() == b"\x7f", "127: must NOT append 0x00; MSB bit is clear"
    assert n127.to_bytes() == b"\xff", "-127: set sign bit (0x7f|0x80)=0xff; no extra byte"
    # sanity: ensure no accidental extra byte got added
    assert p127.to_bytes() != b"\x7f\x00", "127: non-minimal encoding detected (spurious 0x00)"
    assert n127.to_bytes() != b"\xff\x00", "-127: non-minimal encoding detected (spurious 0x00)"
    # round-trips
    assert BitNum.from_bytes(b"\x7f") == p127, "127: from_bytes failed"
    assert BitNum.from_bytes(b"\xff") == n127, "-127: from_bytes failed"


def test_bitnum_msb_edges_boundary_add_byte():
    # 128 / -128 (0x80 has MSB bit set; needs an extra byte)
    p128 = BitNum(128)
    n128 = BitNum(-128)
    assert p128.to_bytes() == b"\x80\x00", "128: must append 0x00 to avoid sign-bit collision"
    assert n128.to_bytes() == b"\x80\x80", "-128: must append 0x80 to carry negative sign"
    # round-trips
    assert BitNum.from_bytes(b"\x80\x00") == p128, "128: from_bytes failed"
    assert BitNum.from_bytes(b"\x80\x80") == n128, "-128: from_bytes failed"


def test_bitnum_msb_edges_two_bytes():
    # 255 / -255
    # 255 magnitude LE is 0xff; MSB bit set -> need an extra byte
    p255 = BitNum(255)
    n255 = BitNum(-255)
    assert p255.to_bytes() == b"\xff\x00", "255: MSB set; positive must append 0x00"
    assert n255.to_bytes() == b"\xff\x80", "-255: MSB set; negative must append 0x80"
    assert BitNum.from_bytes(b"\xff\x00") == p255, "255: from_bytes failed"
    assert BitNum.from_bytes(b"\xff\x80") == n255, "-255: from_bytes failed"

    # 256 / -256
    # magnitude is 0x0100 → LE b"\x00\x01" (MSB byte is 0x01, high bit clear) → no extra byte required
    p256 = BitNum(256)
    n256 = BitNum(-256)
    assert p256.to_bytes() == b"\x00\x01", "256: MSB byte (0x01) has high bit clear; no extra byte"
    assert n256.to_bytes() == b"\x00\x81", "-256: reuse top byte and set sign bit (0x01|0x80=0x81)"
    assert BitNum.from_bytes(b"\x00\x01") == p256, "256: from_bytes failed"
    assert BitNum.from_bytes(b"\x00\x81") == n256, "-256: from_bytes failed"


def test_bitnum_more_msb_cases_across_boundaries():
    # 2**15 - 1 = 32767 → 0x7fff → LE b"\xff\x7f" (top 0x7f, high bit clear) → no extra byte
    p32767 = BitNum(2 ** 15 - 1)
    assert p32767.to_bytes() == b"\xff\x7f", "32767: top byte 0x7f has MSB clear; no extra byte"

    # 2**15 = 32768 → 0x8000 → LE b"\x00\x80" (top 0x80, high bit set) → append 0x00 (positive)
    p32768 = BitNum(2 ** 15)
    assert p32768.to_bytes() == b"\x00\x80\x00", "32768: top byte MSB set; must append 0x00"

    # Negative counterparts
    n32767 = BitNum(-(2 ** 15 - 1))
    assert n32767.to_bytes() == b"\xff\xff", "-32767: set sign bit in top (0x7f→0xff); no extra byte"

    n32768 = BitNum(-(2 ** 15))
    assert n32768.to_bytes() == b"\x00\x80\x80", "-32768: top MSB set; must append 0x80 for sign"


def test_bitnum_round_trip_and_lengths():
    # A set of values straddling byte boundaries; verify minimal length and round-trip
    vectors = [
        0, 1, -1,
        127, -127,
        128, -128,
        255, -255,
        256, -256,
        2 ** 23 - 1, -(2 ** 23 - 1),
        2 ** 23, -(2 ** 23),
    ]
    for n in vectors:
        bn = BitNum(n)
        b = bn.to_bytes()
        rt = BitNum.from_bytes(b)
        assert rt == bn, f"round-trip mismatch for {n}"


def test_bitnum_bytes_identity_after_cache():
    # Ensure repeated to_bytes() calls return same object (cache hit) if implemented
    bn = BitNum(123456)
    b1 = bn.to_bytes()
    b2 = bn.to_bytes()
    assert b1 is b2, "cache: to_bytes() should return same bytes object after first computation"


def test_bitnum_repr_and_int():
    bn = BitNum(-5)
    assert int(bn) == -5, "__int__ mismatch"
    assert "BitNum(-5)" == repr(bn), "__repr__ mismatch"
