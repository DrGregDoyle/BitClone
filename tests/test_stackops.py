"""
Tests for Stack operations | Ox6b -- 0x72
Generated by ChatGPT
"""
# tests/test_stackops.py
import pytest

from src.core import BitStackError
from src.script.opcodes.stackops import (
    op_toaltstack,
    op_fromaltstack,
    op_2drop,
    op_2dup,
    op_3dup,
    op_2over,
    op_2rot,
    op_2swap,
    op_ifdup,
    op_depth,
    op_drop,
    op_dup,
    op_nip,
    op_over,
    op_pick,
    op_roll,
    op_rot,
    op_swap,
    op_tuck,
)
from src.script.stack import BitStack, BitNum


# ----------------------------
# Helpers
# ----------------------------

def stack_top(*items):
    """Create a BitStack where the first argument is the TOP (leftmost)."""
    s = BitStack()
    s.pushlist(list(items))  # pushlist keeps the last in list at top after reversing+appendleft
    return s


def bytes_view(s: BitStack):
    """Canonical bytes view (BitNum -> minimal bytes; bytes unchanged), top->bottom."""
    out = []
    for it in list(s.stack):
        out.append(it if isinstance(it, bytes) else it.to_bytes())
    return out


def bn(i: int) -> BitNum:
    return BitNum(i)


# Short byte labels (just data, not numbers)
A, B, C, D, E, F, G = b"a", b"b", b"c", b"d", b"e", b"f", b"g"


# ----------------------------
# Basic ordering / invariants
# ----------------------------

def test_pushitems_orders_first_as_bottom():
    s = BitStack([A, B, C])  # constructor uses pushitems -> appendleft in input order
    # After pushing A,B,C via appendleft, top should be C, then B, then A
    assert bytes_view(s) == [C, B, A]


# ----------------------------
# Alt stack ops
# ----------------------------

def test_toaltstack_fromaltstack_moves_items():
    main = stack_top(A, B, C)
    alt = BitStack()
    op_toaltstack(main, alt)  # move A (top) -> alt
    assert bytes_view(main) == [B, C]
    assert bytes_view(alt) == [A]

    op_fromaltstack(main, alt)  # move back
    assert bytes_view(main) == [A, B, C]
    assert bytes_view(alt) == []


# ----------------------------
# Pair / triple ops
# ----------------------------

def test_2drop_removes_two():
    s = stack_top(A, B, C)
    op_2drop(s)
    assert bytes_view(s) == [C]


def test_2dup_duplicates_top_two():
    s = stack_top(A, B, C)
    op_2dup(s)
    # a b c -> a b a b c (top->bottom)
    assert bytes_view(s) == [A, B, A, B, C]


def test_3dup_duplicates_top_three():
    s = stack_top(A, B, C, D)
    op_3dup(s)
    # a b c d -> a b c a b c d
    assert bytes_view(s) == [A, B, C, A, B, C, D]


def test_2over_copies_3rd_and_4th_to_top():
    s = stack_top(A, B, C, D, E)
    op_2over(s)
    # a b c d e -> c d a b c d e
    assert bytes_view(s) == [C, D, A, B, C, D, E]


def test_2rot_moves_5th_and_6th_to_top():
    s = stack_top(A, B, C, D, E, F, G)
    op_2rot(s)
    # a b c d e f g -> e f a b c d g
    assert bytes_view(s) == [E, F, A, B, C, D, G]


def test_2swap_swaps_two_pairs():
    s = stack_top(A, B, C, D, E)
    op_2swap(s)
    # a b c d e -> c d a b e
    assert bytes_view(s) == [C, D, A, B, E]


# ----------------------------
# Unary ops / conditionals
# ----------------------------

def test_ifdup_bytes_and_bitnum():
    # bytes non-zero duplicates
    s = stack_top(B, C)
    op_ifdup(s)
    assert bytes_view(s) == [B, B, C]

    # bytes zero (empty) does not duplicate
    s = stack_top(b"", C)
    op_ifdup(s)
    assert bytes_view(s) == [b"", C]

    # BitNum non-zero duplicates
    s = stack_top(bn(2), C)
    op_ifdup(s)
    assert bytes_view(s) == [bn(2).to_bytes(), bn(2).to_bytes(), C]

    # BitNum zero does not duplicate
    s = stack_top(bn(0), C)
    op_ifdup(s)
    assert bytes_view(s) == [bn(0).to_bytes(), C]  # bn(0) -> b""


def test_depth_pushes_height_as_bitnum():
    s = stack_top(A, B, C)
    op_depth(s)
    assert bytes_view(s)[0] == bn(3).to_bytes()


def test_drop_and_dup():
    s = stack_top(A, B, C)
    op_drop(s)
    assert bytes_view(s) == [B, C]

    s = stack_top(A, B, C)
    op_dup(s)
    assert bytes_view(s) == [A, A, B, C]


def test_nip_removes_second():
    s = stack_top(A, B, C, D)
    op_nip(s)
    # a b c d -> a c d
    assert bytes_view(s) == [A, C, D]


# ----------------------------
# Over / Pick / Roll / Rot / Swap / Tuck
# ----------------------------

# @pytest.mark.xfail(reason="OP_OVER implementation in stackops.py pops 3; Script semantics require copying 2nd to top")
def test_over_copies_second_to_top():
    s = stack_top(A, B)
    op_over(s)
    # a b -> b a b
    assert bytes_view(s) == [B, A, B]


def test_pick_valid_and_invalid():
    # valid: copy data n back to top (n on top)
    s = stack_top(A, B, C, D)
    s.push(bn(2).to_bytes())  # n=2 (third data from top -> C)
    op_pick(s)
    assert bytes_view(s) == [C, A, B, C, D]

    # invalid: n >= height should raise BitStackError
    s = stack_top(A, B)
    s.push(bn(2).to_bytes())  # height is 2; n=2 invalid
    with pytest.raises(BitStackError):
        op_pick(s)


def test_roll_moves_nth_to_top():
    s = stack_top(A, B, C, D, E)
    s.push(bn(2).to_bytes())  # move C to top
    op_roll(s)
    assert bytes_view(s) == [C, A, B, D, E]


def test_rot_moves_third_to_top():
    s = stack_top(A, B, C, D)
    op_rot(s)
    # a b c d -> c a b d
    assert bytes_view(s) == [C, A, B, D]


def test_swap_swaps_top_two():
    s = stack_top(A, B, C)
    op_swap(s)
    assert bytes_view(s) == [B, A, C]


def test_tuck_inserts_top_before_second():
    s = stack_top(A, B)
    op_tuck(s)
    # a b -> a b a
    assert bytes_view(s) == [A, B, A]


# ----------------------------
# Error paths / underflow
# ----------------------------

def test_underflow_errors():
    s = BitStack()
    with pytest.raises(BitStackError):
        op_drop(s)
    with pytest.raises(BitStackError):
        op_dup(s)
    with pytest.raises(BitStackError):
        op_2drop(s)
    with pytest.raises(BitStackError):
        op_2dup(s)
    with pytest.raises(BitStackError):
        op_3dup(s)
